<?xml version="1.0"?>
<!-- XXX We intentionally expand several launch files in this launch script to
     expose all hacks for matching namespaces defined by the racecar project -->

<launch>
  <!-- Define constants -->
  <arg name="racecar_version" value="racecar-v2" />
  <arg name="description_param" value="/robot_description" /> <!-- XXX default used in gazebo_ros_control-->

  <!-- REGION Code modified from $(find racecar_gazebo)/launch/racecar.launch -->
  <!-- Define arguments for launch file -->
  <arg name="run_camera" default="false"/>
  <arg name="name" doc="Unique namespace for spawning this car"/>

  <arg name="x" default="0.0"/>
  <arg name="y" default="0.0"/>
  <arg name="z" default="0.05"/>

  <!-- urdf xml robot description loaded on the Parameter Server, converting the xacro into a proper urdf file-->
  <param name="$(arg description_param)" command="$(find xacro)/xacro --inorder '$(find racecar_description)/urdf/racecar.xacro'" />

  <!-- push robot_description to factory and spawn robot in gazebo -->
  <node name="racecar_spawn" pkg="gazebo_ros" type="spawn_model" output="screen" args="
          -param $(arg description_param)
          -urdf
          -x $(arg x)
          -y $(arg y)
          -z $(arg z)
          -robot_namespace $(arg name)/racecar
          -model $(arg name)" respawn="false" />

  <!-- XXX Replace <include file="$(find racecar_control)/launch/racecar_control.launch" /> -->
  <!-- REGION Code modified from $(find racecar_control)/launch/racecar_control.launch -->
  <!-- Load joint controller configurations from YAML file to parameter server -->
  <rosparam file="$(find racecar_control)/config/racecar_control.yaml" command="load" />
  <!-- Load the controllers -->
  <!-- XXX $(find racecar_control)/config/racecar_control.yaml defines all ROS names under racecar/*.
       We therefore need this racecar namespace group -->
  <group ns="racecar">
    <node name="controller_manager" pkg="controller_manager" type="spawner" respawn="false"
          output="screen" args="left_rear_wheel_velocity_controller right_rear_wheel_velocity_controller
                                left_front_wheel_velocity_controller right_front_wheel_velocity_controller
                                left_steering_hinge_position_controller right_steering_hinge_position_controller
                                joint_state_controller" />

    <!-- convert joint states to TF transforms for rviz, etc -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" respawn="false" output="screen">
    </node>
  </group>
  <!-- servo node -->
  <!-- TODO we should define our own servo_commands.py without absolute names -->
  <node pkg="racecar_control" type="servo_commands.py" name="servo_commands" output="screen">
      <remap from="/racecar/ackermann_cmd_mux/output"
         to="vesc/low_level/ackermann_cmd_mux/output"/>
      <remap from="/racecar/left_front_wheel_velocity_controller/command"
               to="racecar/left_front_wheel_velocity_controller/command"/>
      <remap from="/racecar/left_rear_wheel_velocity_controller/command"
               to="racecar/left_rear_wheel_velocity_controller/command"/>
      <remap from="/racecar/left_steering_hinge_position_controller/command"
               to="racecar/left_steering_hinge_position_controller/command"/>
      <remap from="/racecar/right_front_wheel_velocity_controller/command"
               to="racecar/right_front_wheel_velocity_controller/command"/>
      <remap from="/racecar/right_rear_wheel_velocity_controller/command"
               to="racecar/right_rear_wheel_velocity_controller/command"/>
      <remap from="/racecar/right_steering_hinge_position_controller/command"
               to="racecar/right_steering_hinge_position_controller/command"/>
  </node>
  <!-- ENDREGION -->

  <!-- Spawn the MUXs -->
  <!-- XXX Replace <include file="$(find racecar)/launch/mux.launch" ns="vesc" /> -->
  <group ns="vesc">
    <!-- REGION Code modified from $(find racecar)/launch/mux.launch -->
    <!-- Chain the MUXs -->
    <node name="mux_chainer" pkg="topic_tools" type="relay"
          args="high_level/ackermann_cmd_mux/output low_level/ackermann_cmd_mux/input/navigation" />

    <!-- Define mappings for backwards compatibility -->
    <!-- XXX Skipped because we don't need to handle racecar-v1 -->

    <!-- default (zero) ackermann command for high level MUX -->
    <node name="zero_ackermann_cmd" pkg="rostopic" type="rostopic" args="pub -r 6 high_level/ackermann_cmd_mux/input/default ackermann_msgs/AckermannDriveStamped '{header: auto, drive: {steering_angle: 0.0, speed: 0.0} }'" />

    <!-- High level MUX -->
    <include file="$(find ackermann_cmd_mux)/launch/standalone.launch" ns="high_level">
      <arg name="nodelet_manager_name" value="ackermann_cmd_mux_nodelet_manager" />
      <arg name="config_file" value="$(find racecar)/config/$(arg racecar_version)/high_level_mux.yaml" />
    </include>

    <!-- Low level MUX -->
    <include file="$(find ackermann_cmd_mux)/launch/standalone.launch" ns="low_level">
      <arg name="nodelet_manager_name" value="ackermann_cmd_mux_nodelet_manager" />
      <arg name="config_file" value="$(find racecar)/config/$(arg racecar_version)/low_level_mux.yaml" />
    </include>
    <!-- ENDREGION -->
  </group>

  <!-- Allow for Gazebo to broadcast odom -->
  <!-- XXX Skipped because we use VRPN node to broadcast device positions. Also we directly use PoseStamped instead of Odometry
  <node pkg="racecar_gazebo" name="gazebo_odometry_node" type="gazebo_odometry.py"/>
  -->
  <!-- ENDREGION -->
</launch>
